I"∞6<p>Despu√©s de unas semanas con jornadas de trabajo intensas, hoy he vuelto con un tema muy interesante y que desde hace un tiempo he tenido muchas ganas de escribir ya que pienso que es la base y una de las partes fundamentales para escribir un buen software ;pero en el caso de android su uso no es tan com√∫n es por eso que quiero hablar sobre esos beneficios que contrae el usar la inyecci√≥n de dependencias.</p>

<p>Antes de comenzar con la Inyecci√≥n de dependencias hay dos principios que debemos conocer para comprender mejor la motivaci√≥n de usar este patr√≥n y recordar que esto puede ser aplicado en alguna otra plataforma dentro del mundo del software.</p>

<h2 id="inversion-of-control-ioc">Inversion of Control (IoC)</h2>

<p>En los comienzos del desarrollo software cuando los programas eran lineales el flujo de ejecuci√≥n estaba bajo control absoluto del programador, ya que √©l era la persona que especificaba la secuencia y los procedimientos que se ten√≠an que ejecutar con el paso del tiempo comenzaron a aparecer librer√≠as y frameworks con la finalidad de dise√±ar de una forma modular y reutilizable lo que dio origen a la inversi√≥n de control.</p>

<p>La <strong>IoC (Inversi√≥n de control)</strong> es cuando el flujo de ejecuci√≥n de un software est√° bajo el control de alg√∫n framework o librer√≠a y ya no por el desarrollador. En el caso de android la inversi√≥n de control se da en los m√©todos del ciclo de vida de una <a href="https://developer.android.com/training/basics/activity-lifecycle/starting.html">Activity</a>, <a href="https://developer.android.com/guide/components/fragments.html">Fragment</a> y un <a href="https://developer.android.com/guide/components/services.html">Service</a>, ya que son los que dirigen c√≥mo se deben ir ejecutando ciertas partes de una aplicaci√≥n. Lo que realmente debemos entender es que todo el software que escribimos nosotros o al menos en android no somos nosotros los desarrolladores quien tenemos el control completo del flujo de ejecuci√≥n si no el framework y ser√° √©l mismo quien nos est√© diciendo: el usuario ha lanzando una activity, el usuario puls√≥ un checkbox, el usuario pulso un bot√≥n, etc.</p>

<p>En un <a href="http://martinfowler.com/bliki/InversionOfControl.html">post del gran Martin Fowler</a> llama a este fen√≥meno como el
<strong>Hollywood Principle ‚ÄúDon‚Äôt call us, we‚Äôll call you‚Äù</strong> una famosa frase que se les dice a los actores de hollywood tras presentar una audici√≥n y que ejemplifica bastante bien a la <a href="https://es.wikipedia.org/wiki/Inversi%C3%B3n_de_control">IoC</a>.</p>

<h2 id="dependency-inversion">Dependency Inversion</h2>

<p>El principio de Inversi√≥n de Dependencias es uno de los cinco componentes de <a href="http://devexperto.com/principio-responsabilidad-unica">SOLID</a> que si no hab√≠as o√≠do hablar de ellos o ya los conoces sabr√°s que son un conjunto de principios que aplicados correctamente, te ayudar√°n a escribir software de calidad crear√°s c√≥digo que ser√° m√°s f√°cil de testear y mantener.</p>

<p>La palabra <strong>‚Äúinversi√≥n‚Äù</strong> dentro del principio de <strong>Inversi√≥n de Dependencias</strong> viene dentro del t√©rmino porque se invierte el camino en el cual pensamos t√≠picamente el dise√±o de la OO ya que los componentes de bajo nivel dependen de las abstracciones de alto nivel.</p>

<p><em>‚ÄúLas clases de alto nivel no deber√≠an depender de las clases de bajo nivel. Ambas deber√≠an depender de las abstracciones.‚Äù</em></p>

<p>La idea de este principio es la reducci√≥n de dependencias a clases concretas dentro de nuestra aplicaci√≥n, es decir el c√≥digo que es la parte m√°s importante no debe depender de los detalles de implementaci√≥n como pueden ser alg√∫n framework o alguna librer√≠a externa que se utilice. Todos estos aspectos se especificar√°n mediante interfaces y esa parte importante no tendr√° que conocer cu√°l es la implementaci√≥n real para funcionar.</p>

<p><em>‚ÄúLas abstracciones no deber√≠an depender de los detalles. Los detalles deber√≠an depender de las abstracciones.‚Äù</em></p>

<h2 id="coupled-classes">Coupled classes</h2>

<p>Cuando tenemos dos componentes (clases) y uno de ellos depende del otro lo que solemos hacer de forma habitual es crear una instancia dentro de esa clase y hacer lo que tengamos que hacer de una forma muy natural, se ve como algo normal y es que en verdad est√° cumpliendo el objetivo (aunque no de la mejor forma) proveer de sus implementaciones a el componente que las necesite por medio de la creaci√≥n de una instancia.</p>

<p><strong>¬øPero cu√°l es el verdadero problema de hacer esto?</strong></p>

<ul>
  <li>El principal problema de hacer esto es que comenzamos a acoplar nuestras clases y el acoplamiento es uno de los mayores problemas del   software, ya que la idea es que una clase no tenga que crear sus propios objetos.</li>
  <li>Nuestras clases no son flexibles porque no podemos sustituir componentes de forma sencilla.</li>
  <li>No se puede testar una clase acoplada si no hay forma de sustituir su comportamiento por test doubles y por ende no se podr√° testar una clase acoplada de forma aislada.</li>
  <li>Si es un proyecto en el cual se necesitan cambios constantes la mantenibilidad de nuestro software va  a ser un tanto doloroso.</li>
</ul>

<h2 id="what-is-a-dependency">What is a Dependency?</h2>

<p>Es el acoplamiento entre dos m√≥dulos de nuestro c√≥digo en nuestro caso clases y se manifiesta cuando un m√≥dulo necesita de otro para realizar algo.</p>

<h2 id="dependency-injection">Dependency Injection</h2>

<p>La inyecci√≥n de dependencias es un patr√≥n de dise√±o de software que facilita la inversi√≥n de dependencias y se encarga de proveer dependencias en lugar de ser la propia clase quien cree el objeto.
Cuando hablamos de depender de abstracciones estamos haciendo referencia a depender de supertipos que com√∫nmente se consigue mediante una clase abstracta o una interfaz de las cuales no podemos crear una instancia por lo que tenemos que ser capaces de crear la implementaci√≥n concreta y pasarsela al objeto que la necesite mediante un constructor o un setter.</p>

<p>La clase <strong>WeatherForecaster</strong> necesita el objeto <strong>LocationService.</strong></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WeatherForecaster</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">LocationService</span> <span class="n">locationService</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">WeatherForecaster</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">locationService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LocationService</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>La idea es que una clase no tenga que crear sus propios objetos como lo he mencionado arriba esto puede ser un gran problema al momento que nuestro software comienza a crecer ya que testar y mantener se va volver muy complejo.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WeatherForecaster</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">LocationService</span> <span class="n">locationService</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">WeatherForecaster</span><span class="o">(</span><span class="nc">LocationService</span> <span class="n">locationService</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">locationService</span> <span class="o">=</span> <span class="n">locationService</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Al obtener una dependencia por medio del constructor nos va proveer m√°s flexibilidad al momento de necesitar diferentes implementaciones, durante el testing es una gran ventaja ya que permitir√° reemplazar de manera sencilla por alg√∫n test double.</p>

<p>En concreto la inyecci√≥n de dependencias nos permite proveer una dependencia fuera del objeto que la necesita.</p>

<h2 id="what-is-a-dependency-injector">What is a dependency injector?</h2>

<p>La Inyecci√≥n de dependencias en algunas ocasiones puede contraer nuevos problemas y es que si he logrado transmitirte bien los conceptos esperaria que te est√©s haciendo estas preguntas:</p>

<ul>
  <li>Si una clase no puede crear sus propios objetos, ¬øEntonces deber√≠a existir un lugar en donde se crean instancias de los m√≥dulos?</li>
  <li>¬øQu√© hago si un m√≥dulo tiene un mont√≥n de dependencias?</li>
  <li>¬øPuedo tener constructores con muchas dependencias?</li>
  <li>¬øC√≥mo reutilizar dependencias entre objetos ?</li>
</ul>

<p>Un <strong>inyector de dependencias</strong> es aquel que se va encargar de administrar y proveer todas las dependencias que le configuremos y que haremos uso dentro de nuestra aplicaci√≥n.</p>

<p>En android especialmente son de gran utilidad y aportan grandes beneficios, ya que nosotros no podemos acceder al constructor de una Activity o un  Fragment por ejemplo lo que inyectar una dependencia mediante un constructor ser√≠a casi imposible, aun que se puede tambien simular un inyector otras desventajas de no usar un inyector es que nuestro c√≥digo se vuelve sucio e ilegible m√°s cuando se tiene un exceso de dependencias pasadas por el constructor (si cuando ves clases con muchos ‚Äúnew‚Äù) y otra cosa importante es que permite proveer objetos que se utilizan por toda la aplicaci√≥n de una forma simple.</p>

<p>Yo te recomiendo que utilices el inyector que m√°s te guste y mejor entiendas de preferencia que cumpla con el est√°ndar  <em>javax.inject annotations (JSR-330)</em> algunos de los m√°s conocidos que funcionan en android son <a href="https://github.com/google/guice">Guice</a>,  <a href="http://square.github.io/dagger/">Dagger</a>, <a href="http://google.github.io/dagger/">Dagger2</a>(yo uso este).</p>

<p><strong>Algo que quiero que tengas en mente y muy claro es que no es obligatorio el uso de un inyector de dependencias para aplicar la inyecci√≥n de dependencias, ya que solo es una herramienta m√°s que facilita la aplicaci√≥n de este patr√≥n te recomiendo usar un inyector si en verdad lo necesitas y si lo entiendes completamente (es complicado pero no imposible la curva de aprendizaje de dagger 2 por ejemplo no es del todo simple pero es cuesti√≥n de dedicarle tiempo) de lo contrario se podr√≠a convertir en un anti patr√≥n.</strong></p>

<h2 id="conclusion">Conclusion</h2>

<p>Particularmente desde mi punto de vista es la parte m√°s complicada de entender en el mundo del software, ya que requiere un nivel de abstracci√≥n complejo por eso te invito a que tengas paciencia cuando vayas aprendiendo ;pero una vez que lo entiendes te dar√°s cuenta que la parte m√°s importante de aplicar IoC, Dependency Inversion y Dependency Injection es que te va proveer desacoplamiento, modularidad, mantenibilidad, testabilidad lo que es magn√≠fico para nuestro software haciendo tu d√≠a a d√≠a como desarrollador m√°s sencillo.</p>

<p>En este post solo quer√≠a demostrar y dejar muy claros algunos conceptos antes de utilizar un inyector de dependencias sin tener idea del por qu√© lo usamos y terminar haci√©ndolo s√≥lo porque est√° de moda para m√≠ la parte m√°s interesante es conocer la motivaci√≥n del por qu√© usarlo.</p>

<p>Si quieres aprender a usar el inyector de dependencias Dagger2 entonces no te pierdas <a href="https://erikjhordan-rey.github.io/blog/2016/07/07/ANDROID-kata-dagger2.html">mi siguiente art√≠culo</a> que he preparado para t√≠ en donde mediante una kata explico el uso de Dagger2.</p>

<h3 id="demo">Demo</h3>

<h4 id="el-c√≥digo-est√°-disponible">El c√≥digo est√° disponible</h4>

<p><a href="https://github.com/erikjhordan-rey/Dependency-Injection-Android">Dependency-Injection-Android en Github</a></p>

<p><img src="/images/2016/4/battery.png" alt="" /></p>

<h2 id="acknowledgment">Acknowledgment</h2>

<p>Un especial agradecimiento a <a href="https://developers.google.com/experts/people/chiu-ki-chan">Chiu-Ki Chan</a> Google Developer Expert por su gran trabajo en <a href="https://github.com/chiuki/daggerless-di-testing/tree/master">Daggerless Dependency Injection for Testing</a> de donde he tomado su genial ejemplo haciendole unas peque√±as modificaciones.</p>

<h3 id="bonus">Bonus</h3>

<p>if you want to learn how to apply DI using Dagger2 framework.</p>

<p><img src="https://raw.githubusercontent.com/erikjhordan-rey/Dagger2-MVP-Sample/master/art/2015-12-15.png" alt="dagger2-demo" /></p>

<p><a href="https://github.com/erikjhordan-rey/Dagger2-MVP-Sample">Dagger2-MVP-Sample- Github</a></p>

<h3 id="resources">Resources</h3>
<ul>
  <li><strong>Martin Fowler</strong> - <a href="http://martinfowler.com/bliki/InversionOfControl.html">InversionOfControl</a></li>
  <li><strong>Chiu-Ki Chan</strong> - <a href="https://github.com/chiuki/daggerless-di-testing/tree/master">Daggerless Dependency Injection for Testing</a></li>
  <li><strong>Jake Wharton</strong> - <a href="https://www.youtube.com/watch?v=plK0zyRLIP8">The Future of Dependency Injection with Dagger 2</a></li>
  <li><strong>Antonio Leiva</strong> -¬†<a href="http://antonioleiva.com/dependency-injection-android-dagger-part-1/">Dependency Injection-android-dagger</a></li>
  <li><strong>Pedro G√≥mez</strong> - <a href="https://www.youtube.com/watch?v=XY2fHxqEBeo">Dependency Injection on Android</a></li>
</ul>

<p><strong>‚ÄúDepend upon abstractions. Do not depend upon concrete classes‚Äù</strong></p>
:ET