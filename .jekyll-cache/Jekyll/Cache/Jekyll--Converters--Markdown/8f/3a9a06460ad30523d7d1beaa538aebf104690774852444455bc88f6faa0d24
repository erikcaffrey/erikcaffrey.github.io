I"ˆ4<p>En el d√≠a a d√≠a com√∫nmente los equipos de software (mobile) tenemos la responsabilidad de implementar soluciones enfocadas en el negocio, proveer mejoras de funcionalidad, reparar bugs, cumplir con deadlines, entre otras y al final el objetivo es lograr que un usuario pueda disfrutar de nuestro producto de la mejor forma posible.</p>

<p>Para que un build llegue a Google Play Console hay un camino largo y en ocasiones complicado, la falta de automatizaci√≥n de procesos, la no cultura de pruebas automatizadas/manuales o procesos complejos con el equipo de QA, son el tipo de problemas m√°s recurrentes a los que me he enfrentado como developer en diversos proyectos.</p>

<h2 id="generating-manually-app-release">Generating manually app release</h2>

<p><strong>No tienes un buen flujo de release, cuando:</strong></p>

<ul>
  <li>El lead del equipo tiene que generar el build manualmente en su m√°quina.</li>
  <li>S√≥lo un miembro del equipo sabe c√≥mo hacer un release.</li>
  <li>Tienes que conectar un device a tu computadora para que alguien de tu equipo pueda probar esa versi√≥n del apk o el bundle</li>
  <li>Env√≠as un apk por slack, drive, dropbox u otra.</li>
  <li>No puedes hacer de forma f√°cil hotfix, no tienes un release branch o un tag que te permita solucionarlo de forma f√°cil sin tener que pasar toda la regresi√≥n de la versi√≥n.</li>
  <li>Alguien de tu equipo necesita mostrar un avance prematuro y no se puede hacer el release por que se ‚Äúrompe‚Äù en alguna parte.</li>
  <li>Firmas manualmente el apk o bundle y luego arrastras a Google Play Console.</li>
  <li>El equipo de QA no sabe qu√© probar y pregunta cada hora si ya est√° listo el build.</li>
  <li>Te preguntan qu√© incluye este nuevo build</li>
  <li>No es sencillo generar otra versi√≥n tras una regresi√≥n si se encontraron errores y se repararon.</li>
  <li>No puedes liberar en cualquier momento ‚Äúya con lo que tenga no hay tiempo‚Äù</li>
</ul>

<p>Quiz√°s alguno de estos puntos te parezca familiar y probablemente te pasen en tu d√≠a a d√≠a, por tal raz√≥n quiero mostrar el <a href="https://erikjhordan-rey.github.io/blog/2020/03/15/ANDROID-launch-android-apps.html">c√≥mo solucionarlo</a>) aplicando estrategias que ayuden a mejorar la experiencia de hacer un release, quiz√°s te sea de utilidad y logres llevarlo a tu equipo, o te d√© una idea para crear tu propio <a href="https://nvie.com/posts/a-successful-git-branching-model/">flujo</a> de <a href="https://hackernoon.com/a-branching-and-releasing-strategy-that-fits-github-flow-be1b6c48eca2">trabajo</a>, recuerda que cada release impacta a todo el equipo no s√≥lo a los mobile developers.</p>

<h2 id="why-automate-the-app-release-matters">Why automate the app release matters?</h2>

<p>En experiencias pasadas me toc√≥ mirar que se lanzaban aplicaciones de producci√≥n a Google Play sin ser probadas por diversos motivos, mucho tiempo en generar un build, ya se tiene que hacer el release, no hay tiempo, l√°nzalo y luego lo reparamos, etc. El resultado de aplicar estas malas pr√°cticas es: muchos usuarios insatisfechos, uninstalls, malos ratings en google play, crashes en flujos core, baja el n√∫meros de usuarios activos y como consecuencia termina afectado el negocio desafortunadamente.</p>

<p><strong>Alguna razones m√°s por la cuales importa automatizar:</strong></p>

<ul>
  <li>Podemos agregar valor m√°s r√°pido a usuarios</li>
  <li>Tu equipo de QA le ser√° m√°s simple probar tu software</li>
  <li>Controlar cada versi√≥n de tu aplicaci√≥n, mediante un tag o release branch</li>
  <li>Evitar malos ratings y comentarios en Google Play por un build mal generado</li>
  <li>Mantener un elevado crash-free users dado que se deben cumplir las pruebas automatizadas y en ocasiones pruebas del equipo de QA.</li>
  <li>Todo el equipo puede y tiene el conocimiento para hacer un release</li>
  <li>Podemos obtener feedback r√°pido</li>
  <li>Es f√°cil atender hotfixes</li>
  <li>Visibilidad para que todo el equipo pueda ir viendo avances y saben qu√© est√° pasando</li>
  <li>Personas no tech pueden probar la app de forma simple.</li>
</ul>

<h2 id="understanding-automation-software-strategies">Understanding automation software strategies</h2>

<h4 id="continuous-integration">Continuous Integration</h4>

<p>En la pr√°ctica significa que los miembros de un equipo tengan la facilidad de integrar su trabajo a un core <strong>(master, develop u otro)</strong> branch, normalmente se hace mediante un pull request para asegurar que la futura integraci√≥n no contiene errores y si los tiene detectarlos de forma r√°pida. 
Es aqu√≠ donde la compilaci√≥n automatizada, verificaci√≥n de code style, code analysis, linters, y la suite de tests automatizados se ejecuta, es la forma que tienes para mantener tu repositorio core fuera de sorpresas.</p>

<h4 id="continuous-delivery">Continuous Delivery</h4>

<p>Es una disciplina y forma de hacer software en la cual tiene como objetivo que siempre se pueda llevar build a producci√≥n en cualquier momento. Es una pr√°ctica compleja dado que requiere de procesos internos y mejorar formas de trabajo dentro del equipo, como bien sabemos para distribuir una aplicaci√≥n en Google Play requiere de ser firmada antes lo que dificulta un poco m√°s la implementaci√≥n.</p>

<p>En este caso podr√≠amos decir que no hacemos del todo <a href="https://martinfowler.com/bliki/ContinuousDelivery.html">continuous delivery</a> por el simple hecho de poner un build de forma automatizada y requerir de presionar un bot√≥n para hacer el release en Google Play Store o <a href="https://firebase.google.com/docs/app-distribution">Firebase App Distribution</a> por que el flujo de trabajo que usamos es enfocado m√°s a desarrollar features; pero tampoco hacemos <strong>continuous development</strong> porque cada cosa que integramos nuevo c√≥digo no va a producci√≥n directamente, va a nuestro ambiente de pruebas.</p>

<p>As√≠ que para mantenerlo simple y sin ponernos un tanto filos√≥ficos <strong>automatizar un release de android</strong> lo resumir√≠a en la forma en la que mantenemos el producto de software en estado liberable, lo que permite llevar a producci√≥n funciones de manera r√°pida, as√≠ como responder ante cualquier falla que pueda ocurrir.</p>

<h2 id="tooling-to-automate-android-releases">Tooling to automate android releases</h2>

<h3 id="continuous-integration-tool">Continuous Integration Tool</h3>

<p>Existen algunas alternativas en el mercado que te pueden ayudar a implementar CI dependiendo las necesidades de tu proyecto. En mi experiencia he podido usar gran parte de estas herramientas, la complejidad de integraci√≥n en ocasiones depende mucho de qu√© plataforma git utilizas <a href="https://bitbucket.org/product/">bitbucket</a>, <a href="https://about.gitlab.com/">gitlab</a>, <a href="https://github.com/">github</a> u otro; pero la mayor√≠a de veces la configuraci√≥n es similar.</p>

<p>Actualmente utilizamos <a href="https://docs.travis-ci.com/">Travis CI</a> dado que tenemos alojado el proyecto en github, y es la herramienta que mejor dominamos en el equipo, a√∫n as√≠  puedes mirar otras alternativas:</p>

<ul>
  <li><a href="https://docs.travis-ci.com/">Travis CI</a></li>
  <li><a href="https://jenkins.io/doc/">Jenkins</a></li>
  <li><a href="https://circleci.com/">Circle CI</a></li>
  <li><a href="https://www.bitrise.io/">Bitrise</a></li>
  <li><a href="https://about.gitlab.com/stages-devops-lifecycle/continuous-integration/">GitLab CI</a></li>
  <li><a href="https://www.atlassian.com/es/software/bamboo">Bamboo</a></li>
</ul>

<h3 id="app-distribution">App Distribution</h3>

<p>Desde hace unos a√±os he utilizado <a href="https://docs.fabric.io/android/beta/overview.html">Fabric Beta</a> para distribuir un apk con los diversos equipos donde que he colaborado y hacer todo tipo de pruebas antes de llegar a producci√≥n en Google Play. En el 2017 <a href="https://firebase.google.com/docs/crashlytics">Crashlytics</a> fue adquirido por Google con Fabric incluido, al d√≠a de hoy Fabric est√° <strong>deprecated</strong> y est√° por cerrar el <em>31 de Marzo de 2020</em>, as√≠ que si no lo sab√≠as sugiero que migres a <a href="https://firebase.google.com/?hl=es-419">Firebase</a> en los siguientes d√≠as.</p>

<h3 id="firebase-app-distribution">Firebase App Distribution</h3>

<p>Es la herramienta que nos permite compartir nuestra aplicaci√≥n con testers externos o internos de una forma simple, ya que basta con compartir un link de invitaci√≥n para poder convertirte en tester de la aplicaci√≥n. Si est√°s familiarizado con Fabric entenderlo ser√° m√°s simple.</p>

<p>Existen 4 formas de distribuir una app en Firebase App Distribution:</p>

<ul>
  <li><a href="https://firebase.google.com/docs/app-distribution/android/distribute-console">Firebase console</a></li>
  <li><a href="https://firebase.google.com/docs/app-distribution/android/distribute-cli">Firebase CLI</a></li>
  <li><a href="https://firebase.google.com/docs/app-distribution/android/distribute-fastlane">fastlane</a></li>
  <li><a href="https://firebase.google.com/docs/app-distribution/android/distribute-gradle">Gradle</a></li>
</ul>

<p>Si deseas integrarlo con tu servicio de <a href="https://martinfowler.com/articles/continuousIntegration.html">continuous integration</a> la opci√≥n a utilizar es gradle o fastlane si tu proyecto lo utiliza. En nuestro caso utilizamos la configuraci√≥n de gradle para integrar con <a href="https://docs.travis-ci.com/">Travis CI</a>.</p>

<h2 id="launch-workflow">Launch workflow</h2>

<p>Tener un flujo de trabajo establecido har√° que el flujo de lanzamiento sea simple y para garantizar la calidad de la aplicaci√≥n suelo implementarlo con la siguiente estrategia.</p>

<h3 id="debug-release">Debug Release</h3>

<p>Distribuye un apk de forma autom√°tica en <a href="https://firebase.google.com/docs/app-distribution">firebase app distribution</a> cada que se hace un <strong>merge a master</strong> y Travis CI termina de ejecutar el job. Es una versi√≥n inestable que contiene los √∫ltimos cambios en master y es completamente para el equipo de desarrollo.</p>

<h3 id="prod-release">Prod Release</h3>

<p>Distribuye un apk de forma autom√°tica en <a href="https://firebase.google.com/docs/app-distribution">firebase app distribution</a> cada que se crea un <strong>release branch</strong> y Travis CI termina de ejecutar el job. Es una versi√≥n candidata para liberar en producci√≥n es probada por el equipo de QA y si no hay errores se crea un <strong>tag</strong> que terminara deployando en <a href="https://play.google.com/store">Google Play Store</a>.</p>

<p><img src="/images/2020/3/work-flow.png" alt="workflow" class="center-image" /></p>

<p>Usamos un branch <strong>master</strong> es el lugar donde se encuentra todo el proyecto, para integrar c√≥digo es necesario crear una pull requests contra master. El Job de <strong>Travis CI</strong> comenzar√° a ejecutar el build para asegurar que todo sigue compilando, se ejecutar√° el an√°lisis de c√≥digo y la suite de tests, si todo estuvo correcto y la <strong>pull requests</strong> fue aprobada por el equipo se hace el merge a master, autom√°ticamente se va generar un build de desarrollo en <a href="https://firebase.google.com/docs/app-distribution">firebase app distribution</a> con un release notes que contiene el √∫ltimo commit del branch, de esta forma el equipo puede probar en cualquier momento lo que existe en master. Cuando requiere liberar a <strong>producci√≥n</strong> primero se crea un <strong>release branch</strong> para que el equipo de QA pueda realizar una regresi√≥n con una versi√≥n de producci√≥n, en ocasiones hay escenarios que solo suceden en producci√≥n por ‚Äúalguna raz√≥n‚Äù, si encontramos problemas reparamos en en release branch y hacemos el fix tambi√©n en <strong>master</strong> para evitar crear otro release dado que en ocasiones ya se ha incluido m√°s c√≥digo que no es parte del release actual, cuando todo est√° correcto se genera un <strong>tag</strong> que termina deployando un build en Google Play en el stage ‚Äúinternal‚Äù, as√≠ nosotros controlamos a que stages liberar alfa, beta o producci√≥n y el porcentaje en el que lo queremos realizar.</p>

<h3 id="conclusion">Conclusion</h3>

<p>El objetivo de este primer post es entender los problemas a los que nos enfrentamos en el d√≠a a d√≠a como mobile developers al momento de generar un release, mostrar las estrategias que podemos utilizar para resolverlo y los problemas que nos trae el no tener un flujo de liberaci√≥n definido. En el <a href="https://erikjhordan-rey.github.io/blog/2020/03/15/ANDROID-launch-android-apps.html">siguiente post</a> compartir√© algunos tips para que puedas implementarlo en tu proyecto.</p>

<p><a href="https://erikjhordan-rey.github.io/blog/2020/03/15/ANDROID-launch-android-apps.html">Leer Parte 2</a></p>

<p><strong>¬°Espero que sea de ayuda y si lo encuentras interesante ay√∫dame a compartirlo!</strong></p>

<h4 id="further-reading">Further reading</h4>

<ul>
  <li><a href="https://martinfowler.com/bliki/ContinuousDelivery.html">Continuous Delivery</a></li>
  <li><a href="https://martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a></li>
  <li><a href="https://hackernoon.com/a-branching-and-releasing-strategy-that-fits-github-flow-be1b6c48eca2">A Branching and Releasing Strategy That Fits GitHub Flow</a></li>
  <li><a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a></li>
</ul>
:ET